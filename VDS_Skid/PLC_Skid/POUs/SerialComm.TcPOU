<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="SerialComm" Id="{c693bfc9-ff64-4bf3-8160-0b021daf2d1e}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM SerialComm
VAR
	(* background communication with the PC COM port device *)
	(* Background ADS Control *)
	fbSerialLineControlADS 	: SerialLineControlADS;
	stSerialConfig 			: ComSerialConfig; (* Using the struct above *)
	PumpCmds				: ST_AtlasPumpCmd;
	//eSelectedAction 		: EN_AtlasPumpAction := EN_AtlasPumpAction.IDLE;

	(* Status Outputs from the block *)
    bPortOpened            : BOOL;
    bError                 : BOOL;
    nErrorID               : UDINT;

	(* Command Logic *)
    fbSend            : SendString;
    fbReceive         : ReceiveString;

	(* Initialization flag *)
    bInitialized           : BOOL := FALSE;

    (* Inputs/Outputs *)
	iState            	: INT := 0;
	sCommandToSend  	: STRING;
    sResponse         	: STRING;       // Holds the received response
    bReceived         	: BOOL;         // Flashes TRUE when a message arrives
    tonTimeout        	: TON;          // To catch if the device never responds
	sCleanResponse		: STRING;

	(* PC Control Heartbeat *)
	bInPCControl		: BOOL := FALSE;	// TRUE when pump confirmed in PC Control mode
	bHeartbeatOK		: BOOL := FALSE;	// TRUE if last heartbeat succeeded
	tonHeartbeat		: TON;				// 2s interval timer for heartbeat
	bIsHeartbeat		: BOOL := FALSE;	// TRUE if current command is heartbeat (not manual)
	sActiveCommand		: STRING;			// The command currently being sent

	(* PC Control Exit *)
	ftrigPCControl		: F_TRIG;			// Falling edge detection for bEnablePCControl
	bExitingPCControl	: BOOL := FALSE;	// TRUE while sending A0 exit command
	bIsExitCommand		: BOOL := FALSE;	// TRUE if current command is A0 exit

	(* Manual Command Status *)
	bCommandDone		: BOOL := FALSE;	// Pulses TRUE when manual command completes
	bCommandTimeout		: BOOL := FALSE;	// TRUE if last manual command timed out

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// 1. Set configuration values (Run only once)
IF NOT bInitialized THEN
    stSerialConfig.ComPort    := 8;            // Matches your USB adapter
    stSerialConfig.Baudrate   := 57600;
    stSerialConfig.Parity     := PARITY_NONE;
    stSerialConfig.DataBits   := 8;
    stSerialConfig.StopBits   := STOPBITS_ONE;

    // CRITICAL: Prevent USB blocking by enabling these
    stSerialConfig.DTR        := DTR_CTRL_ENABLE;
    stSerialConfig.RTS        := RTS_CTRL_ENABLE;

    bInitialized := TRUE;
END_IF

// Detect falling edge of bEnablePCControl to trigger A0 exit command
ftrigPCControl(CLK := GVL_Serial.bEnablePCControl);
IF ftrigPCControl.Q AND bInPCControl THEN
    bExitingPCControl := TRUE;  // Flag to send A0 command
END_IF

// Clear heartbeat timer when PC Control disabled
IF NOT GVL_Serial.bEnablePCControl AND NOT bExitingPCControl THEN
    tonHeartbeat(IN := FALSE);
END_IF

(* 1. ALWAYS run the background communication first *)
fbSerialLineControlADS(
    Connect  := TRUE,
    SerialCfg:= stSerialConfig,
    NetId    := '',                      	(* Local CX5330 *)
    Timeout  := T#5S,
    TxBuffer := GVL_Serial.TxBufferPcCom,
    RxBuffer := GVL_Serial.RxBufferPcCom,
    PortOpened => bPortOpened,
    Error      => bError,
    ErrorID    => nErrorID);

(* 2. Heartbeat timer - runs when PC Control enabled, state machine is idle, and no manual command pending *)
tonHeartbeat(IN := GVL_Serial.bEnablePCControl AND bPortOpened AND (iState = 0) AND NOT GVL_Serial.bStartCommand, PT := T#2S);

(* 3. Command State Machine *)
CASE iState OF
    0: (* IDLE - Check for exit command, manual command, then heartbeat *)
        bCommandDone := FALSE;  // Clear completion flag

        // A0 Exit command takes highest priority
        IF bExitingPCControl AND bPortOpened THEN
            bIsHeartbeat    := FALSE;
            bIsExitCommand  := TRUE;
            sActiveCommand  := 'A0$R$L';
            sResponse       := '';
            iState          := 10;

        // Manual command via enum selection
        ELSIF GVL_Serial.eSelectedAction <> EN_AtlasPumpAction.IDLE AND bPortOpened THEN
            (* Map the Selection to the specific Struct String *)
            CASE GVL_Serial.eSelectedAction OF
                EN_AtlasPumpAction.STOP_LEFT:   sCommandToSend := PumpCmds.StopLeft;
                EN_AtlasPumpAction.STOP_RIGHT:  sCommandToSend := PumpCmds.StopRight;
                EN_AtlasPumpAction.PAUSE:       sCommandToSend := PumpCmds.Pause;
                EN_AtlasPumpAction.UNPAUSE:     sCommandToSend := PumpCmds.Unpause;
                EN_AtlasPumpAction.EMPTY_LEFT:  sCommandToSend := PumpCmds.EmptyLeft;
                EN_AtlasPumpAction.EMPTY_RIGHT: sCommandToSend := PumpCmds.EmptyRight;
                EN_AtlasPumpAction.FILL_LEFT:   sCommandToSend := PumpCmds.FillLeft;
                EN_AtlasPumpAction.FILL_RIGHT:  sCommandToSend := PumpCmds.FillRight;
            END_CASE
            GVL_Serial.eSelectedAction := EN_AtlasPumpAction.IDLE;  // Clear selection
            bIsHeartbeat    := FALSE;
            bIsExitCommand  := FALSE;
            bCommandTimeout := FALSE;
            sActiveCommand  := CONCAT(sCommandToSend, '$R$L');
            sResponse       := '';
            iState          := 10;

        // Manual command via bStartCommand trigger
        ELSIF GVL_Serial.bStartCommand AND bPortOpened THEN
            GVL_Serial.bStartCommand := FALSE;
            bIsHeartbeat    := FALSE;
            bIsExitCommand  := FALSE;
            bCommandTimeout := FALSE;
            sActiveCommand  := CONCAT(sCommandToSend, '$R$L');
            sResponse       := '';
            iState          := 10;

        // Heartbeat fires when timer elapses
        ELSIF GVL_Serial.bEnablePCControl AND bPortOpened AND tonHeartbeat.Q THEN
            tonHeartbeat(IN := FALSE); 	// Reset timer
            bIsHeartbeat    := TRUE;
            bIsExitCommand  := FALSE;
            sActiveCommand  := 'A1$R$L';
            sResponse       := '';
            iState          := 10;
        END_IF

    10: (* SEND command *)
        fbSend(
            SendString := sActiveCommand,
            TxBuffer   := GVL_Serial.TxBufferPcCom);

        IF NOT fbSend.Busy THEN
            iState := 20;
        END_IF

    20: (* WAIT FOR RESPONSE *)
        fbReceive(
            Prefix         := '',
            Suffix         := '$R$L',
            Timeout        := T#1S,
            ReceivedString := sResponse,
            RxBuffer       := GVL_Serial.RxBufferPcCom,
            StringReceived => bReceived);

        tonTimeout(IN := TRUE, PT := T#2S);

        IF bReceived THEN
            tonTimeout(IN := FALSE);
            // Remove trailing CR/LF from response
            sCleanResponse := LEFT(sResponse, LEN(sResponse) - 2);

            // Check if this was an exit command (A0)
            IF bIsExitCommand THEN
                // A0 response is "#A" - check if we got it
                IF sCleanResponse = '#A' THEN
                    bInPCControl := FALSE;
                    bHeartbeatOK := FALSE;
                END_IF
                bExitingPCControl := FALSE;
                bIsExitCommand := FALSE;

            // Check if this was a heartbeat (A1)
            ELSIF bIsHeartbeat THEN
                // A1 response is "#A" - check if we got it
                IF sCleanResponse = '#A' THEN
                    bInPCControl := TRUE;
                    bHeartbeatOK := TRUE;
                ELSE
                    bHeartbeatOK := FALSE;
                END_IF

            ELSE
                // Manual command completed successfully
                bCommandDone := TRUE;
            END_IF
            iState := 0;

        ELSIF tonTimeout.Q THEN
            tonTimeout(IN := FALSE);
            // Timeout handling
            IF bIsExitCommand THEN
                // Exit command timed out - clear flags anyway
                bExitingPCControl := FALSE;
                bIsExitCommand := FALSE;
                bInPCControl := FALSE;
                bHeartbeatOK := FALSE;
            ELSIF bIsHeartbeat THEN
                bHeartbeatOK := FALSE;
                bInPCControl := FALSE;  // Lost communication, assume not in PC Control
            ELSE
                // Manual command timed out
                bCommandTimeout := TRUE;
                bCommandDone := TRUE;
            END_IF
            iState := 0;
        END_IF
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>