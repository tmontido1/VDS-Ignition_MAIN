<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FBUO_OPPump_AcetonePrime" Id="{e2f3a4b5-6789-0abc-def1-445566778899}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FBUO_OPPump_AcetonePrime
VAR_INPUT
    bEnable             : BOOL;         // Enable the function block
    bStartAcetonePrime  : BOOL;         // Start the priming process (rising edge)
    nSyringeCycles      : INT := 2;     // Number of fill/empty cycles
END_VAR

VAR_OUTPUT
    bBusy               : BOOL;         // Priming in progress
    bDone               : BOOL;         // Priming complete
    bError              : BOOL;         // Error occurred
    nCurrentStep        : INT;          // Current step for diagnostics
    nCurrentCycle       : INT;          // Current cycle number (1 to nSyringeCycles)
END_VAR

VAR
    // State machine
    nState              : INT := 0;

    // Edge detection
    rtrigStart          : R_TRIG;

    // Timing
    tonDelay            : TON;

    // Cycle counter
    nCycleCount         : INT := 0;

    // Tracking fill started (saw BUSY state)
    bAxis0FillStarted   : BOOL;
    bAxis1FillStarted   : BOOL;

    // Tracking fill complete (saw IDLE after BUSY)
    bAxis0FillDone      : BOOL;
    bAxis1FillDone      : BOOL;

    // Tracking empty started (saw BUSY state)
    bAxis0EmptyStarted  : BOOL;
    bAxis1EmptyStarted  : BOOL;

    // Tracking empty complete (saw IDLE after BUSY)
    bAxis0EmptyDone     : BOOL;
    bAxis1EmptyDone     : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* FBUO_OPPump_AcetonePrime
   Purpose: Prime syringes with acetone (or other solvent)
   Process:
   1. Fill both syringes (wait for IDLE)
   2. Empty both syringes (wait for IDLE)
   3. Repeat for nSyringeCycles times
   4. End with syringes empty after last cycle

   Commands are offset by 100ms to avoid serial bus contention
   Uses _PRIME speed commands
*)

// Edge detection on Start
rtrigStart(CLK := bStartAcetonePrime AND bEnable);

// Reset outputs when disabled
IF NOT bEnable THEN
    nState := 0;
    bBusy := FALSE;
    bDone := FALSE;
    bError := FALSE;
    nCycleCount := 0;
    nCurrentCycle := 0;
    bAxis0FillStarted := FALSE;
    bAxis1FillStarted := FALSE;
    bAxis0FillDone := FALSE;
    bAxis1FillDone := FALSE;
    bAxis0EmptyStarted := FALSE;
    bAxis1EmptyStarted := FALSE;
    bAxis0EmptyDone := FALSE;
    bAxis1EmptyDone := FALSE;
    tonDelay(IN := FALSE);
    RETURN;
END_IF

// State machine
CASE nState OF

    0: // IDLE - Wait for start
        nCurrentStep := 0;
        nCurrentCycle := 0;
        bBusy := FALSE;
        bDone := FALSE;
        bError := FALSE;
        nCycleCount := 0;

        IF rtrigStart.Q THEN
            bBusy := TRUE;
            nCycleCount := 1;
            nCurrentCycle := 1;
            nState := 10;
        END_IF

    // ===== FILL PHASE =====

    10: // FILL_LEFT - Send Fill command for axis 0
        nCurrentStep := 1;
        // Reset tracking flags for this cycle
        bAxis0FillStarted := FALSE;
        bAxis1FillStarted := FALSE;
        bAxis0FillDone := FALSE;
        bAxis1FillDone := FALSE;
        GVL_Serial.eSelectedAction := EN_AtlasPumpAction.FILL_LEFT_PRIME;
        nState := 15;

    15: // WAIT_FILL_LEFT_ACK - Wait for command to be processed
        IF GVL_Serial.eSelectedAction = EN_AtlasPumpAction.IDLE THEN
            tonDelay(IN := FALSE);
            nState := 20;
        END_IF

    20: // FILL_DELAY - Wait 100ms before sending next command
        tonDelay(IN := TRUE, PT := T#100MS);
        IF tonDelay.Q THEN
            tonDelay(IN := FALSE);
            nState := 30;
        END_IF

    30: // FILL_RIGHT - Send Fill command for axis 1
        nCurrentStep := 2;
        GVL_Serial.eSelectedAction := EN_AtlasPumpAction.FILL_RIGHT_PRIME;
        nState := 35;

    35: // WAIT_FILL_RIGHT_ACK - Wait for command to be processed
        IF GVL_Serial.eSelectedAction = EN_AtlasPumpAction.IDLE THEN
            nState := 40;
        END_IF

    40: // WAIT_FILL_BUSY - Wait for both axes to show BUSY (confirms fill started)
        nCurrentStep := 3;

        // Check if axis 0 has started (BUSY)
        IF GVL_Serial.stPumpStatus[0].Valid AND GVL_Serial.stPumpStatus[0].IsBusy THEN
            bAxis0FillStarted := TRUE;
        END_IF

        // Check if axis 1 has started (BUSY)
        IF GVL_Serial.stPumpStatus[1].Valid AND GVL_Serial.stPumpStatus[1].IsBusy THEN
            bAxis1FillStarted := TRUE;
        END_IF

        // Both started - now wait for them to finish
        IF bAxis0FillStarted AND bAxis1FillStarted THEN
            nState := 45;
        END_IF

    45: // WAIT_FILL_IDLE - Wait for both axes to go IDLE (fill complete)
        nCurrentStep := 4;

        // Check if axis 0 has gone IDLE (fill complete)
        IF GVL_Serial.stPumpStatus[0].Valid AND GVL_Serial.stPumpStatus[0].IsIdle THEN
            bAxis0FillDone := TRUE;
        END_IF

        // Check if axis 1 has gone IDLE (fill complete)
        IF GVL_Serial.stPumpStatus[1].Valid AND GVL_Serial.stPumpStatus[1].IsIdle THEN
            bAxis1FillDone := TRUE;
        END_IF

        // Both fill complete - proceed to empty phase
        IF bAxis0FillDone AND bAxis1FillDone THEN
            tonDelay(IN := FALSE);
            nState := 50;
        END_IF

    // ===== EMPTY PHASE =====

    50: // EMPTY_LEFT - Send Empty command for axis 0
        nCurrentStep := 5;
        // Reset tracking flags for empty phase
        bAxis0EmptyStarted := FALSE;
        bAxis1EmptyStarted := FALSE;
        bAxis0EmptyDone := FALSE;
        bAxis1EmptyDone := FALSE;
        GVL_Serial.eSelectedAction := EN_AtlasPumpAction.EMPTY_LEFT_PRIME;
        nState := 55;

    55: // WAIT_EMPTY_LEFT_ACK - Wait for command to be processed
        IF GVL_Serial.eSelectedAction = EN_AtlasPumpAction.IDLE THEN
            tonDelay(IN := FALSE);
            nState := 60;
        END_IF

    60: // EMPTY_DELAY - Wait 100ms before sending next command
        tonDelay(IN := TRUE, PT := T#100MS);
        IF tonDelay.Q THEN
            tonDelay(IN := FALSE);
            nState := 70;
        END_IF

    70: // EMPTY_RIGHT - Send Empty command for axis 1
        nCurrentStep := 6;
        GVL_Serial.eSelectedAction := EN_AtlasPumpAction.EMPTY_RIGHT_PRIME;
        nState := 75;

    75: // WAIT_EMPTY_RIGHT_ACK - Wait for command to be processed
        IF GVL_Serial.eSelectedAction = EN_AtlasPumpAction.IDLE THEN
            nState := 76;
        END_IF

    76: // WAIT_EMPTY_BUSY - Wait for both axes to show BUSY (confirms empty started)
        nCurrentStep := 7;

        // Check if axis 0 has started (BUSY)
        IF GVL_Serial.stPumpStatus[0].Valid AND GVL_Serial.stPumpStatus[0].IsBusy THEN
            bAxis0EmptyStarted := TRUE;
        END_IF

        // Check if axis 1 has started (BUSY)
        IF GVL_Serial.stPumpStatus[1].Valid AND GVL_Serial.stPumpStatus[1].IsBusy THEN
            bAxis1EmptyStarted := TRUE;
        END_IF

        // Both started - now wait for them to finish
        IF bAxis0EmptyStarted AND bAxis1EmptyStarted THEN
            nState := 78;
        END_IF

    78: // WAIT_EMPTY_IDLE - Wait for both axes to go IDLE (empty complete)
        nCurrentStep := 8;

        // Check if axis 0 has gone IDLE (empty complete)
        IF GVL_Serial.stPumpStatus[0].Valid AND GVL_Serial.stPumpStatus[0].IsIdle THEN
            bAxis0EmptyDone := TRUE;
        END_IF

        // Check if axis 1 has gone IDLE (empty complete)
        IF GVL_Serial.stPumpStatus[1].Valid AND GVL_Serial.stPumpStatus[1].IsIdle THEN
            bAxis1EmptyDone := TRUE;
        END_IF

        // Both empty complete - check if more cycles needed
        IF bAxis0EmptyDone AND bAxis1EmptyDone THEN
            nState := 80;
        END_IF

    // ===== CYCLE CHECK =====

    80: // CHECK_CYCLES - Check if more cycles needed
        nCurrentStep := 9;

        IF nCycleCount < nSyringeCycles THEN
            // More cycles needed - increment and go back to fill
            nCycleCount := nCycleCount + 1;
            nCurrentCycle := nCycleCount;
            nState := 10;
        ELSE
            // All cycles complete - done (syringes are empty)
            nState := 100;
        END_IF

    // ===== COMPLETE =====

    100: // DONE - Priming complete
        nCurrentStep := 10;
        bBusy := FALSE;
        bDone := TRUE;

        // Wait for bStartAcetonePrime to go FALSE before allowing restart
        IF NOT bStartAcetonePrime THEN
            nState := 0;
        END_IF

END_CASE
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>
