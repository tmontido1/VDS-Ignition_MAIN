<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{1957c99f-7c6a-48c3-b96f-a44a4ae5f1ca}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	//---------- HMI configs ------------------//
	content 			: ARRAY[0..10] OF INT;
	fbRtContent 		: ARRAY[0..10] OF R_TRIG;
	contentSelect		: BOOL;
	fbTpContentSelect	: TP;
	x, y				: INT;
	myVariable			: REAL;
	//-----------------------------------------//
	
	t : ULINT;  // Task execution time
	TimerSine   : TON;          // Timer for elapsed time
    rElapsedSec : REAL;         // Elapsed seconds (REAL)
    rPeriodSec  : REAL := 2.0;  // Sine period in seconds
    rAngle      : REAL;
	
	i : INT; //Initialization Counter
	CycleCount : INT := 0; // Cycle counter to split 
    Initialized : BOOL := FALSE; // Flag for initialization
	CtrlStatus : INT; // Status output
// Valve Names	

	Valves : ARRAY[1..gvl.valveCount] OF ST_valveSignals; // Array for 2 valves
    // Constant array of valve names
    ValveNames : ARRAY[1..gvl.valveCount] OF STRING[20] := ['Dilution Selector', 'WFI Selector', 'Formation Drain', 'WFI Bypass Inlet'];	

// Instantiate Function Blocks
	valveCtrl : FB_valveControl; // Function block instance
	varPulse : FB_PulseValve;   // Instance of the function block
// Bool	
	outputDO1 : BOOL;           // Local output variable
    tPulseTime : TIME := T#1500MS; // Pulse duration
	outputDO3 : BOOL := FALSE;
	outputAO3 : REAL;
	bTurnWFIOn : BOOL := FALSE;
	outputA03 : REAL := 2;
	
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[//----------- HMI ---------------//
a_010_Content();
//------------------------------//

//-----------------------------Process Code ----------------------------------------//
// Initialization
IF NOT Initialized THEN
    FOR i := 1 TO gvl.valveCount DO
        Valves[i].Name := ValveNames[i]; // Assign valve names
        Valves[i].State := 0; // Initialize to Closed
        Valves[i].AO1 := 0.0; // Closed position
        Valves[i].Status := 0; // No faults
        Valves[i].hOpenClose := FALSE; // Initialize to closed
    END_FOR
    Initialized := TRUE;
END_IF


// Call function block
ValveCtrl(fbValveNames := ValveNames, fbValves := Valves, Status => CtrlStatus);
gvl.gvAnOut1_dilutionSV := Valves[1].AO1;
gvl.gvAnOut1_wfiSV := Valves[2].AO1;
gvl.gvAnOut1_formDrain := Valves[3].AO1;
gvl.gvAnOut1_wfiBypassIn := Valves[4].AO1;
// Handle status (optional)
IF CtrlStatus > 0 THEN
    // Log error (e.g., to HMI) if valve(s) not found
END_IF

CycleCount := CycleCount + 1;



IF CycleCount MOD 2 = 1 THEN // Odd cycles (e.g., 1, 3, 5) - check DI1
    FOR i := 1 TO GVL.valveCount DO
        CASE i OF
            1: // dilutionSV
                Valves[i].DI1 := gvl.gvDigIn1_dilutionSV;
				Valves[i].AI1 := gvl.gvAnIn1_dilutionSV;
            2: // wfiSV
                Valves[i].DI1 := gvl.gvDigIn1_wfiSV;
				Valves[i].AI1 := gvl.gvAnIn1_wfiSV;
			3: // formDrain
                Valves[i].DI1 := gvl.gvDigIn1_formDrain;
				Valves[i].AI1 := gvl.gvAnIn1_formDrain;
			4: // formDrain
                Valves[i].DI1 := gvl.gvDigIn1_wfiBypassIn;
				Valves[i].AI1 := gvl.gvAnIn1_wfiBypassIn;
        END_CASE
    END_FOR
ELSIF CycleCount MOD 2 = 0 THEN // Even cycles (e.g., 2, 4, 6) - check DI2
    FOR i := 1 TO GVL.valveCount DO
        CASE i OF
            1: // dilutionSV
                Valves[i].DI2 := gvl.gvDigIn2_dilutionSV;
				Valves[i].AI1 := gvl.gvAnIn1_dilutionSV;
            2: // wfiSV
                Valves[i].DI2 := gvl.gvDigIn2_wfiSV;
				Valves[i].AI1 := gvl.gvAnIn1_wfiSV;
			3: // formDrain
                Valves[i].DI2 := gvl.gvDigIn2_formDrain;
				Valves[i].AI1 := gvl.gvAnIn1_formDrain;
			4: // formDrain
                Valves[i].DI2 := gvl.gvDigIn2_wfiBypassIn;
				Valves[i].AI1 := gvl.gvAnIn1_wfiBypassIn;
        END_CASE
    END_FOR
END_IF


// Correct function block call with inputs
varPulse(Valve := outputDO1, pulseTime := tPulseTime);
// Assign output to global I/O
gvl.gvDigOut1_dilutionSV := outputDO1;


// Pump Control - TBD
gvl.DO3 := outputDO3;
IF bTurnWFIOn THEN
// 	outputAO3 := IO.AO3 := 5;
	gvl.AO3 := outputA03;
ELSE
	gvl.AO3 := 0;
END_IF
//-----------------------------Process Code ----------------------------------------//







// //--------------------Sine wave Test -------------------------------//
// // Start timer on first scan (free-running)
// TimerSine(IN := TRUE, PT := T#100000000MS);  // Max time = 1000s
// 
// // Get elapsed time in seconds
// rElapsedSec := TIME_TO_REAL(TimerSine.ET) / 1000.0;
// 
// // Modulo period → clean wave
// rElapsedSec := rElapsedSec - TRUNC(rElapsedSec / rPeriodSec) * rPeriodSec;
// 
// // Generate sine
// rAngle := (rElapsedSec / rPeriodSec) * 2.0 * 3.1415926535;
// GVL.rSineWave := SIN(rAngle);]]></ST>
    </Implementation>
    <Action Name="a_010_Content" Id="{0033b6c0-2e45-0872-0450-8b64094c5b8f}">
      <Implementation>
        <ST><![CDATA[// Rising edge button ucContent
FOR x := 0 TO 10 DO
    fbRtContent[x](CLK := content[x] = 10);
END_FOR

// Reset all pages
FOR y := 0 TO 10 DO
    IF fbRtContent[y].Q THEN
        contentSelect := TRUE;
        FOR x := 0 TO 10 DO
            content[x] := 0;
        END_FOR
        content[y] := 10; // hold on to the triggered page
    END_IF
END_FOR

// Page selection with delay
fbTpContentSelect(IN := contentSelect, PT := T#15MS, Q => contentSelect);

IF contentSelect THEN
    RETURN;
END_IF // Update page status after switching / white is delayed

// Here you can edit the status of the pages

// Page 1
content[1] := 0;

// Page 2
content[2] := 0;

// Page 2
content[3] := 0;]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>