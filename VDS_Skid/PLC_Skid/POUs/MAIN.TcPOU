<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{1957c99f-7c6a-48c3-b96f-a44a4ae5f1ca}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
//-------------------- Program Initialization Variables ----------------------------//
	i : INT; //Initialization Counter
	CycleCount : INT := 0; // Cycle counter
	Initialized : BOOL := FALSE; // Flag for initialization
	CtrlStatus : INT; // Status output
//----------------------------------------------------------------------------------//


//--------------------------------- Struct Init ------------------------------------//
// Constant array of valve names	
	stValves : ARRAY[1..gvl.valveCount] OF ST_valveSignals;
//----------------------------------------------------------------------------------//


//----------------------------INIT Function Blocks----------------------------------//
	valveCtrl : FB_valveControl; // Function block instance
	varPulse : FB_PulseValve;   // Instance of the function block
//----------------------------------------------------------------------------------//	
	
// Bool	
	outputDO1 : BOOL;           // Local output variable
    tPulseTime : TIME := T#1500MS; // Pulse duration
	outputDO3 : BOOL := FALSE;
	outputAO3 : REAL;
	bTurnWFIOn : BOOL := FALSE;
	outputA03 : REAL := 2;
	
//---------------------INIT Control Variables---------------------------------------//
	hOP_ProcessState			: BOOL	:= FALSE;	// Overpressure process step active
	hOP_ValvesPositioned	 	: BOOL 	:= FALSE;	// Position Valves
	hOP_PumpActive				: BOOL	:= FALSE;	// Turn on Pump
//----------------------------------------------------------------------------------//
	
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[//-----------------------------Process Code ----------------------------------------//
// Initialization
IF NOT Initialized THEN
    FOR i := 1 TO gvl.valveCount DO
        stValves[i].Name := GVL.sValveNames[i]; // Assign valve names
        stValves[i].State := 0; // Initialize to Closed
        stValves[i].AO1 := 0.0; // Closed position
        stValves[i].Status := 0; // No faults
        stValves[i].hOpenClose := FALSE; // Initialize to closed
    END_FOR
    Initialized := TRUE;
END_IF

//------------------------------ Check Valve Inputs Every Cycle ------------------------------//
method_checkValveInputs(
	meCheckProcessState := TRUE, 
	meValves 			:= stValves);
//--------------------------------------------------------------------------------------------//


//------------------------- Overpressure Process (Development Only) --------------------------//
method_OverPressure(
	meOPprocessState 	:= hOP_ProcessState := TRUE,
	meValvePositionReady 	:= hOP_ValvesPositioned, 
	meValves 			:= stValves);
//--------------------------------------------------------------------------------------------//

CycleCount := CycleCount + 1;


// Correct function block call with inputs
varPulse(Valve := outputDO1, pulseTime := tPulseTime);
// Assign output to global I/O
gvl.gvDigOut1_dilutionSV := outputDO1;


// Pump Control - TBD
gvl.DO3 := outputDO3;
IF bTurnWFIOn THEN
// 	outputAO3 := IO.AO3 := 5;
	gvl.AO3 := outputA03;
ELSE
	gvl.AO3 := 0;
END_IF
//-----------------------------Process Code ----------------------------------------//
]]></ST>
    </Implementation>
    <Method Name="method_checkValveInputs" Id="{c985539e-4eba-05d6-07b1-841c56d8c333}">
      <Declaration><![CDATA[METHOD method_checkValveInputs : BOOL
VAR_INPUT
	meCheckProcessState :	BOOL;
END_VAR
VAR_IN_OUT
    meValves : ARRAY[1..gvl.valveCount] OF ST_valveSignals;
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF meCheckProcessState THEN
	meValves[1].DI1 := gvl.gvDigIn1_dilutionSV;
	meValves[1].AI1 := gvl.gvAnIn1_dilutionSV;
	meValves[1].DI2 := gvl.gvDigIn2_dilutionSV;

	meValves[2].DI1 := gvl.gvDigIn1_wfiSV;
	meValves[2].AI1 := gvl.gvAnIn1_wfiSV;
	meValves[2].DI2 := gvl.gvDigIn2_wfiSV;

	meValves[3].DI1 := gvl.gvDigIn1_formDrain;
	meValves[3].AI1 := gvl.gvAnIn1_formDrain;
	meValves[3].DI2 := gvl.gvDigIn2_formDrain;

	meValves[4].DI1 := gvl.gvDigIn1_wfiBypassIn;
	meValves[4].AI1 := gvl.gvAnIn1_wfiBypassIn;
	meValves[4].DI2 := gvl.gvDigIn2_wfiBypassIn;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="method_OverPressure" Id="{f5df7d36-2695-0399-2719-78342c48306a}">
      <Declaration><![CDATA[METHOD method_OverPressure : BOOL
VAR_INPUT
    meOPprocessState : BOOL;
    meValvePositionReady : BOOL;
END_VAR
VAR_IN_OUT
    meValves : ARRAY[1..gvl.valveCount] OF ST_valveSignals;
END_VAR
VAR
    i : INT;
    j : INT;
    valveNames : ARRAY[1..2] OF STRING := ['Dilution Selector', 'Formation Drain'];
    targetState : INT;
    targetOpenClose : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF meOPprocessState THEN
    IF meValvePositionReady THEN
        targetState := 1;
        targetOpenClose := TRUE;
    ELSE
        targetState := 0;
        targetOpenClose := FALSE;
    END_IF
    
    FOR i := 1 TO 2 DO		// change this for the number of valves.
        FOR j := 1 TO GVL.valveCount DO
            IF meValves[j].name = valveNames[i] THEN
                meValves[j].state := targetState;
                meValves[j].hOpenClose := targetOpenClose;
                EXIT;
            END_IF
        END_FOR
    END_FOR;
    ValveCtrl(fbValves := meValves);
    gvl.gvAnOut1_dilutionSV := meValves[1].AO1;
    gvl.gvAnOut1_wfiSV := meValves[2].AO1;
    gvl.gvAnOut1_formDrain := meValves[3].AO1;
    gvl.gvAnOut1_wfiBypassIn := meValves[4].AO1;
	
	
	
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="zARCHIVE_method_OverPressure" Id="{5c2f25ba-3a09-058f-0efb-d6d78eec8de5}">
      <Declaration><![CDATA[METHOD zARCHIVE_method_OverPressure : BOOL
VAR_INPUT
methodOPprocessState	: BOOL; // Process method is active
methodOPActive			: BOOL; // Turns the OverPressure Method On
END_VAR

VAR_IN_OUT
    methodValves 	: ARRAY[1..gvl.valveCount] OF ST_valveSignals;   // Array of valve structures
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF methodOPprocessState THEN
	IF methodOPActive THEN
		methodValves[1].state := 1;
		methodValves[1].hOpenClose := TRUE;
		methodValves[2].state := 1;
		methodValves[2].hOpenClose := TRUE;
	ELSE
		methodValves[1].state := 0;
		methodValves[1].hOpenClose := FALSE;
		methodValves[2].state := 0;
		methodValves[2].hOpenClose := FALSE;
	END_IF
	ValveCtrl(fbValves := methodValves);
	gvl.gvAnOut1_dilutionSV := methodValves[1].AO1;
	gvl.gvAnOut1_wfiSV := methodValves[2].AO1;
	gvl.gvAnOut1_formDrain := stValves[3].AO1;
	gvl.gvAnOut1_wfiBypassIn := stValves[4].AO1;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>