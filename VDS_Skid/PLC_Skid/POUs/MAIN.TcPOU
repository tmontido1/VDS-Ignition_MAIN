<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{1957c99f-7c6a-48c3-b96f-a44a4ae5f1ca}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
//-------------------- Program Initialization Variables ----------------------------//
	i : INT; //Initialization Counter
	CycleCount : INT := 0; // Cycle counter
	Initialized : BOOL := FALSE; // Flag for initialization
	CtrlStatus : INT; // Status output
//----------------------------------------------------------------------------------//


//--------------------------------- Struct Init ------------------------------------//
// Constant array of valve names	
	stValves : ARRAY[1..gvl.valveCount] OF ST_Valves;
//----------------------------------------------------------------------------------//


//----------------------------INIT Function Blocks----------------------------------//
	valveCtrl : FB_valveControl; // Function block instance
	varPulse : FB_PulseValve;   // Instance of the function block
//----------------------------------------------------------------------------------//	
	
// Bool	
	outputDO1 : BOOL;           // Local output variable
    tPulseTime : TIME := T#1500MS; // Pulse duration
	outputDO3 : BOOL := FALSE;
	outputAO3 : REAL;
	outputA03 : REAL := 2;
	
//---------------------INIT Control Variables---------------------------------------//
	hOP_ProcessState			: BOOL	:= FALSE;	// Overpressure process step active
	hOP_ValvesPositioned	 	: BOOL 	:= FALSE;	// Position Valves
	hOP_PumpActive				: BOOL	:= FALSE;	// Turn on Pump
	hOP_PumpSpeed				: REAL 	:= 0;		// Pump Speed
//----------------------------------------------------------------------------------//

END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[//-----------------------------Process Code ----------------------------------------//
// Initialization
IF NOT Initialized THEN
    FOR i := 1 TO gvl.valveCount DO
        stValves[i].Name := GVL.sValveNames[i]; // Assign valve names
        stValves[i].State := 0; // Initialize to Closed
        stValves[i].AO1 := 0.0; // Closed position
        stValves[i].Status := 0; // No faults
        stValves[i].hOpenClose := FALSE; // Initialize to closed
    END_FOR
    Initialized := TRUE;
END_IF

//------------------------------ Check Valve Inputs Every Cycle ------------------------------//
method_checkValveInputs(
	meCheckProcessState := TRUE, 
	meValves 			:= stValves);
//--------------------------------------------------------------------------------------------//


//------------------------- Overpressure Process (Development Only) --------------------------//
method_OverPressure(
	meOPprocessState 		:= hOP_ProcessState := TRUE,
	meValvePositionReady 	:= hOP_ValvesPositioned, 
	meValves 				:= stValves,
	mePumpActive			:=	hOP_PumpActive,
	mePumpSpeed				:= hOP_PumpSpeed);
//--------------------------------------------------------------------------------------------//

CycleCount := CycleCount + 1;


// Correct function block call with inputs
varPulse(Valve := outputDO1, pulseTime := tPulseTime);
// Assign output to global I/O
gvl.DO1_dilutionSV := outputDO1;


// Pump Control - TBD
gvl.DO_wfiPump := outputDO3;
IF hOP_PumpActive THEN
// 	outputAO3 := IO.AO3 := 5;
	gvl.AO_wfiPump := outputA03;
ELSE
	gvl.AO_wfiPump := 0;
END_IF
//-----------------------------Process Code ----------------------------------------//
]]></ST>
    </Implementation>
    <Method Name="method_checkValveInputs" Id="{c985539e-4eba-05d6-07b1-841c56d8c333}">
      <Declaration><![CDATA[METHOD method_checkValveInputs : BOOL
VAR_INPUT
	meCheckProcessState :	BOOL;
END_VAR
VAR_IN_OUT
    meValves : ARRAY[1..gvl.valveCount] OF ST_Valves;
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF meCheckProcessState THEN
	meValves[1].DI1 := gvl.DI1_dilutionSV;
	meValves[1].AI1 := gvl.AI1_dilutionSV;
	meValves[1].DI2 := gvl.DI2_dilutionSV;

	meValves[2].DI1 := gvl.DI1_wfiSV;
	meValves[2].AI1 := gvl.AI1_wfiSV;
	meValves[2].DI2 := gvl.DI2_wfiSV;

	meValves[3].DI1 := gvl.DI1_formDrain;
	meValves[3].AI1 := gvl.AI1_formDrain;
	meValves[3].DI2 := gvl.DI2_formDrain;

	meValves[4].DI1 := gvl.DI1_wfiBypassIn;
	meValves[4].AI1 := gvl.AI1_wfiBypassIn;
	meValves[4].DI2 := gvl.DI2_wfiBypassIn;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="method_OverPressure" Id="{f5df7d36-2695-0399-2719-78342c48306a}">
      <Declaration><![CDATA[METHOD method_OverPressure : BOOL
VAR_INPUT
    meOPprocessState 		: BOOL;
    meValvePositionReady 	: BOOL;
	mePumpActive 			: BOOL;
	mePumpSpeed				: REAL;
END_VAR
VAR_IN_OUT
    meValves : ARRAY[1..gvl.valveCount] OF ST_Valves;
END_VAR
VAR
    i : INT;
    j : INT;
    valveNames : ARRAY[1..GVL.valveCount] OF STRING := ['Dilution Selector', 'Formation Drain'];
	numValvesToPosition : INT := 2;
    targetState : INT;
    targetOpenClose : BOOL;
	fbSetValvesOpen : FB_SetValvesOpen;
	fbSetValvesClose : FB_SetValvesClose;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF meOPprocessState THEN
    IF meValvePositionReady THEN
        fbSetValvesOpen(
            fbValveNames := valveNames,
            fbNumValvesToPosition := numValvesToPosition,
            fbValves := meValves);
    ELSE
      	fbSetValvesClose(
            fbValveNames := valveNames,
            fbNumValvesToPosition := numValvesToPosition,
            fbValves := meValves);
    END_IF
    
    ValveCtrl(fbValves := meValves);
    gvl.AO1_dilutionSV := meValves[1].AO1;
    gvl.AO1_wfiSV := meValves[2].AO1;
    gvl.AO1_formDrain := meValves[3].AO1;
    gvl.AO1_wfiBypassIn := meValves[4].AO1;
	
//-----------------------PUMP Control ----------------------//	
	IF hOP_PumpActive THEN
	// 	outputAO3 := IO.AO3 := 5;
		GVL.DO_wfiPump := mePumpActive;
		GVL.AO_wfiPump := mePumpSpeed;
	ELSE
		GVL.DO_wfiPump := mePumpActive;
		GVL.AO_wfiPump := 0;
	END_IF	
//---------------------------------------------------------//	
END_IF




// IF meOPprocessState THEN
//     IF meValvePositionReady THEN
//         targetState := 1;
//         targetOpenClose := TRUE;
//     ELSE
//         targetState := 0;
//         targetOpenClose := FALSE;
//     END_IF
//     
//     FOR i := 1 TO numValvesToPosition DO		// change this for the number of valves.
//         FOR j := 1 TO GVL.valveCount DO
//             IF meValves[j].name = valveNames[i] THEN
//                 meValves[j].state := targetState;
//                 meValves[j].hOpenClose := targetOpenClose;
//                 EXIT;
//             END_IF
//         END_FOR
//     END_FOR;
//     ValveCtrl(fbValves := meValves);
//     gvl.gvAnOut1_dilutionSV := meValves[1].AO1;
//     gvl.gvAnOut1_wfiSV := meValves[2].AO1;
//     gvl.gvAnOut1_formDrain := meValves[3].AO1;
//     gvl.gvAnOut1_wfiBypassIn := meValves[4].AO1;
// 	
// 	
// 	
// 	
// END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="zARCHIVE_method_OverPressure" Id="{5c2f25ba-3a09-058f-0efb-d6d78eec8de5}">
      <Declaration><![CDATA[METHOD zARCHIVE_method_OverPressure : BOOL
VAR_INPUT
methodOPprocessState	: BOOL; // Process method is active
methodOPActive			: BOOL; // Turns the OverPressure Method On
END_VAR

VAR_IN_OUT
    methodValves 	: ARRAY[1..gvl.valveCount] OF ST_Valves;   // Array of valve structures
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF methodOPprocessState THEN
	IF methodOPActive THEN
		methodValves[1].state := 1;
		methodValves[1].hOpenClose := TRUE;
		methodValves[2].state := 1;
		methodValves[2].hOpenClose := TRUE;
	ELSE
		methodValves[1].state := 0;
		methodValves[1].hOpenClose := FALSE;
		methodValves[2].state := 0;
		methodValves[2].hOpenClose := FALSE;
	END_IF
	ValveCtrl(fbValves := methodValves);
	gvl.AO1_dilutionSV := methodValves[1].AO1;
	gvl.AO1_wfiSV := methodValves[2].AO1;
	gvl.AO1_formDrain := stValves[3].AO1;
	gvl.AO1_wfiBypassIn := stValves[4].AO1;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>